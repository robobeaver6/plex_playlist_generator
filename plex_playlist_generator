#!/usr/bin/python3.8

import argparse
import random

import certifi
import requests
import time

#Additional import
import random
import xmltodict

from plexapi.myplex import MyPlexAccount
from plexapi.server import PlexServer
from plexapi.playlist import Playlist
from plexapi.exceptions import NotFound
from plexapi.exceptions import Unauthorized
from plexapi.exceptions import BadRequest

import tvdb_api
import re
import logging

logging.basicConfig()
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

args = None

#string seperators
colon = ':'
comma = ','

# list of series to never include
BLACKLIST = ['Downton Abbey',
             'Poldark (2015)'
             ]


#################################################################################
###                        Before running this script                         ###    
#################################################################################
# [Requirements]                                                                #
#  1. The Library section names for you're plex libraries must be unique.       #
#  2. The Library section names cannot exceed 20 characters.                    #
#################################################################################



def get_args():
    parser = argparse.ArgumentParser(description='Create playlist of unwatched episodes from random shows '
                                                 'but in correct episode order.')
    parser.add_argument('--name', help='Playlist Name', default='[Auto-Generated]')
    parser.add_argument('--number', '-n', help='Number of episodes to add to play list', type=int, default=10)
    parser.add_argument('--homeusers', help='The Plex home user profile name. Comma seperated list with no space immediately following the comma (if selecting multiple users)', type=str)
    #Used for Entering the Admin user(s) 
    parser.add_argument('--adminuser', '-a', help='The Plex Admin user profile name. Comma seperated list (if selecting multiple users)', action='store_true', default=False)
    parser.add_argument('--purge', help='Instead of adding the playlist entered by the user with the \"--name\" argument, instead remove the playlist if it exist', action='store_true', default=False) 
    parser.add_argument('--select-library', '-l', help='Choose The Library\'s you want to select media from')    
    parser.add_argument('--allshows', help='Grab All Shows in all Library sections From Plex', action='store_true', default=False)
    parser.add_argument('--allmovies', help='Grab All Movies in all Library sections From Plex', action='store_true', default=False)
    #The Exclude data will be used in conjuction with either --allshows or --allmovies
    parser.add_argument('--exclude-library', '-e', help='Comma seperated list (if selecting multiple users) of sections to exclude (I.E. "Test Videos,Workout,Home Videos" ) there should be no space between the comma and the first character of the next value', type=str, default="Videos,Workout,Anime (Uncensored),Anime Music Videos,Anime Music,Children's TV Shows")
    group_server = parser.add_argument_group('Server Connection Method')
    group_server.add_argument('--server', action='store_true', help='Server connection Method')
    group_server.add_argument('--baseurl', '-b', help='Base URL of Server (I.E \"http://10.1.1.8:32400\" or \"https://your.domain.com:32400\")', type=str, default="http://localhost:32400")
    group_server.add_argument('--token', '-t', help='Authentication Token')
    group_account = parser.add_argument_group('Plex Account Connection Method')
    group_account.add_argument('--account', action='store_true', help='Account Connection Method')
    group_account.add_argument('--username', '-u', help='Plex Account Username')
    group_account.add_argument('--password', '-p', help='Plex AccountPassword')
    group_account.add_argument('--resource', '-r', help='Resource Name (Plex Server Name)')
    group_account.add_argument('--tvdb-api-key', help='TVDB API Key)')
    group_behaviour = parser.add_argument_group('Episode Selection Behaviour')
    group_behaviour.add_argument('--ignore-skipped', action='store_true', help="Don't test for missing episodes")
    group_behaviour.add_argument('--randomize', action='store_true', help='Randomize selected episodes, not next unwatched')
    group_behaviour.add_argument('--include-watched', action='store_true', help='include watched movies or episodes (use with --randomize')
    parser.add_argument('--debug', '-d', help='Debug Logging', action="store_true")
    return parser.parse_args()



def get_random_episodes(all_shows, n=10):
    show_episodes = dict()
    for show in all_shows.all():
        if args.include_watched is True:
            if args.randomize is False:
                logger.warning("Setting --randomized flag, or playlist will always start at Episode 1 for each series")
                args.randomize = True
            if args.ignore_skipped is False:
                logger.warning("Setting --ignore-skipped flag, missing episode check is not compatible with --randomized option flag")
                args.ignore_skipped = True

        if show.isWatched and args.include_watched is not True:
            continue
        if show.title in BLACKLIST:
            logger.debug(f'GET_EPISODES: Show Blacklisted: {show.title}')
            continue
        if args.include_watched is True:
            #show_episodes[show.title] = show.episodes()
            #Grab Watched Episodes but ignore Season 0 (Specials)
            show_episodes[show.title] = show.episodes(parentIndex__gt=0)
        else:
            show_episodes[show.title] = show.unwatched()

        # remove series 0 specials
        while show_episodes[show.title][0].seasonNumber == 0:
            season_episode = show_episodes[show.title][0].seasonEpisode
            episode_title = show_episodes[show.title][0].seasonEpisode
            show_episodes[show.title].pop(0)
            logger.debug(f'get_random_episodes: Series 0 Episode Removed '
                         f'{show.title} - {episode_title} - {season_episode}')
    next_n = []
    while len(next_n) < n:
        show_name = random.choice(list(show_episodes.keys()))

        if len(show_episodes[show_name]) >0:
            if args.ignore_skipped is False:
                if skipped_missing(all_shows.get(title=show_name), show_episodes[show_name][0]):
                    continue
            if args.randomize:
                random.shuffle(show_episodes[show_name])
                
            next_n.append(show_episodes[show_name].pop(0))

        else:
            logger.debug(f'GET_EPISODES: No more unwatched episodes for {show_name}')
            continue
    return next_n
    
    
def get_random_movies(all_movies, n=10):
    movies_found = dict()
    movies_found_list = list()
    movies_found_key_list = list()
    
    movieCounter = 0
    print(f'all_movies [type]: {type(all_movies)}')
    print(f'\nall_movies = {all_movies}')
    print(f'\nGetting all_movies [unwatched] = {all_movies.all(unwatched=True)}\n')    
                             
    # next_n = []
    while len(movies_found_list) < n:
        
        if(args.include_watched == True):
            #If the user selects to include watched movies
            print(f'\nIncluding Watched Movies...\n')
            movie = random.choice(all_movies.all())

        else:
            #If the user did not select to include watched movies with --include-watched
            print(f'\nExcluding Unwatched Movies...\n')
            movie = random.choice(all_movies.all(unwatched=True))

        movies_found_list.append(movie)
        
    logger.debug(f'Returning list of movies: {movies_found_list}')
    return movies_found_list



def tvdb_season_count(show, season):
    tvdb_id = None
    try:
        logger.debug(f'TVDB: Getting show "{show.title}"')
        tvdb_id = int(re.search('thetvdb://([0-9]+)?', show.guid).group(1))
        if args.tvdb_api_key is None:
            raise RuntimeError(f'TVDB now requires an API key.  Instructions on how to set it up are here:\n\n'
                               f'https://koditips.com/create-tvdb-api-key-tv-database/')
        tv = tvdb_api.Tvdb(language='en', apikey=args.tvdb_api_key)
        season_list = tv[tvdb_id][season]
        logger.debug(f'TVDB: Previous Season Length = {len(season_list)}')
        return len(season_list)
    except tvdb_api.tvdb_seasonnotfound:
        logger.warning(f'TVDB: Unable to look up "{show.title}" ({tvdb_id})')
        return None


def skipped_missing(show, episode):
    try:
        season_num = episode.seasonNumber
        episode_num = episode.index

        if episode.index > 1:
            logger.debug(f'SKIP_CHECK: Check same Season for {show.title} S{season_num}E{episode_num-1}')
            show.get(season=episode.seasonNumber, episode=episode.index-1)
            logger.debug(f'SKIP_CHECK: Passed')
            return False
        elif episode.seasonNumber > 1:
            previous_season_count = tvdb_season_count(show, season_num - 1)
            if previous_season_count is None:
                return False
            logger.debug(f'SKIP_CHECK: Check previous Season for {show.title} S{season_num-1}E{previous_season_count}')
            # check last episode of previous season
            show.get(season=episode.seasonNumber - 1, episode=previous_season_count)
            logger.debug(f'SKIP_CHECK: Passed')
            return False
        else:
            logger.debug(f'SKIP_CHECK: First Episode of First Season. {show.title} {season_num}')
            return False
    except NotFound:
        logger.info(f'SKIP_CHECK: Previous Episode not Found for {show.title} S{season_num}E{episode_num}')
        return True


def delete_playlist(plex, account, playlistName):
    try:
        print(f'\ndeleting playlist \"{playlistName}\"...\n')
        plex.playlist(title=playlistName).delete()
        print(f'\nplaylist \"{playlistName}\" deleted successfully.\n')
        
        #If the user is deleting all instances of the playlist then sleeps are added to avoid hitting the too many request exception
        if(args.purge):
            time.sleep(5)

    except NotFound:
        logger.debug(f"Playlist {playlistName} does not exist to delete.")
        
        #If the user is deleting all instances of the playlist then sleeps are added to avoid hitting the too many request exception
        if(args.purge):
            time.sleep(10)

    except BadRequest as e:
        print(f'Error - BadRequest',e)


#Loops through and builds the playlist
#Arguments are the plex connection, the name of the user we are acting as for playlist generation, the formatted plex library sections, and the Excluded List of Library Sections
def build_playlist(plex, userName, plex_refined_library_sections, selectionsToExclude_List):  
    #The plex_refined_library_sections is the library sections after removing the excluded list
    #The librarySelection is the selected library that was passed in whether from using --allshows, --allmovies, or --selectlibrary

    count = 0

    #If the user selected libraries with the --selectlibrary argument
    if(args.select_library != None):
        randomSelectedLibrary = random.choice(plex_refined_library_sections)
    else:
        randomSelectedLibrary = random.choice(plex_refined_library_sections)

    getPlexLibrarySection = plex.library.section(randomSelectedLibrary)
    
    
    #while count <= args.number:
    while (1):
        randomSelectedLibrary = random.choice(plex_refined_library_sections)
        
        logger.debug(f'\nSelected Library: \"{randomSelectedLibrary}\"\n')

        getPlexLibrarySection = plex.library.section(randomSelectedLibrary)
        logger.debug(f'getPlexLibrarySection = {getPlexLibrarySection}')

        if randomSelectedLibrary in plex_refined_library_sections:
        
            all_Shows_or_Movies_Library_Selection = plex.library.section(randomSelectedLibrary)
            print(f'all_Shows_or_Movies_Library_Selection = {all_Shows_or_Movies_Library_Selection}\n')
            
            
            if (args.select_library != None):

                #The name of the library sections type IE (MovieSection, ShowSection, MusicSection, PhotoSection) its used to query the type of data too grab from the plex API
                getMovieSection = 'MovieSection'
                getShowSection = 'ShowSection'
                
                #use to query and find show sections from the for command if statement
                getShowSectionSearcher = '<' + getShowSection + colon
                getMovieSectionSearcher = '<' + getMovieSection + colon
                
                if getShowSectionSearcher in str(all_Shows_or_Movies_Library_Selection):
                    episode_or_movie = get_random_episodes(all_Shows_or_Movies_Library_Selection, n=1)
                    
                    print('\n\n-----------------------------------')
                    print('[RANDOMIZED EPISODES]')
                    print(f'Username: {userName}')
                    print(f'Library Selection: {randomSelectedLibrary}\n')
                    print(f'\nEpisode Name: \"{episode_or_movie}\"')
                    print(f'\nExcluded Library Sections: {selectionsToExclude_List}')
                    print('-----------------------------------\n\n')
                    
                elif getMovieSectionSearcher in str(all_Shows_or_Movies_Library_Selection):
                    episode_or_movie = get_random_movies(all_Shows_or_Movies_Library_Selection, n=1)
                    
                    print('\n\n-----------------------------------')
                    print('[RANDOMIZED MOVIES]')
                    print(f'Username: {userName}\n')
                    print(f'Library Selection: {randomSelectedLibrary}\n')
                    print(f'\nMovie Name: \"{episode_or_movie}\"')
                    print(f'\nExcluded Library Sections: {selectionsToExclude_List}')
                    print('-----------------------------------\n\n')

                else:
                    print(f'ERROR - Unknown Library Section \"{all_Shows_or_Movies_Library_Selection}\"')
                    exit(1)


                if count == 0:
                    try:
                        #If a playlist with the same name already exist, delete it
                        if plex.playlist(title=args.name):
                            print(f'The playlist "{args.name}" already exist.')
                            print(f'deleting playlist "{args.name}" ...')
                            plex.playlist(title=args.name).delete()

                    except NotFound as e: 
                        logger.debug(f"Playlist {args.name} does not exist to delete.")

                    print(f'\nCreating Playlist ... \n')
                    
                    #Create Playlist 
                    createdPlaylist = Playlist.create(server=plex, title=args.name, items=episode_or_movie, section=None, smart=False, limit=None, libtype=None, sort=None, filters=None, m3ufilepath=None)
                                 
                    print(f'\nCreated Playlist: {args.name}')
                    print(f'\nAdded to Playlist [{args.name}]: {createdPlaylist.items()}\n')

                    #if the number of loops is equal to or greater than the number passed in as an argument with args.number break out of the loop
                    if count >= args.number:
                       break
                   
                    else:
                        count += 1

                else:
                    print(f'\nAdding to Playlist ...\n')
                    
                    #Add to Playlist
                    createdPlaylist.addItems(items=episode_or_movie)

                    print(f'\nAdded to Playlist [{args.name}]: {createdPlaylist.items()}\n')

                    #if the number of loops is equal to or greater than the number passed in as an argument with args.number break out of the loop
                    if count >= args.number:
                       break
                   
                    else:
                        count += 1
            

            #For TV Shows
            elif ((args.select_library != None) or (args.allshows == True)) and args.allmovies == False:
                episodes = get_random_episodes(all_Shows_or_Movies_Library_Selection, n=1)

                print('\n\n-----------------------------------')
                print('[RANDOMIZED EPISODES]')
                print(f'Username: {userName}')
                print(f'Library Selection: {randomSelectedLibrary}\n')
                print(f'\nEpisode Name: \"{episodes}\"')
                print(f'\nExcluded Library Sections: {selectionsToExclude_List}')
                print('-----------------------------------\n\n')

                for episode in episodes:
                    season_episode = episode.seasonEpisode      
                    print(f'{episode.grandparentTitle} - {episode.parentTitle} - '
                          f'{episode.index}. {episode.title}')
                
                if count == 0:
                    try:
                        #If a playlist with the same name already exist, delete it
                        if plex.playlist(title=args.name):
                            print(f'The playlist "{args.name}" already exist.')
                            print(f'deleting playlist "{args.name}" ...')
                            plex.playlist(title=args.name).delete()

                    except NotFound as e: 
                        logger.debug(f"Playlist {args.name} does not exist to delete.")

                    print(f'\nCreating Playlist ... \n')
       
                    #Create Playlist 
                    createdPlaylist = Playlist.create(server=plex, title=args.name, items=episodes, section=None, smart=False, limit=None, libtype=None, sort=None, filters=None, m3ufilepath=None)
                   
                    print(f'\nCreated Playlist: {args.name}')
                    print(f'\nAdded to Playlist [{args.name}]: {createdPlaylist.items()}\n')
                    
                    count += 1
                
                    #if the number of loops is equal to or greater than the number passed in as an argument with args.number break out of the loop
                    if count >= args.number:
                       break
                else:
                    print(f'\nAdding to Playlist ...\n')
                    
                    #Add to Playlist
                    createdPlaylist.addItems(items=episodes)

                    print(f'\nAdded to Playlist [{args.name}]: {createdPlaylist.items()}\n')

                    count += 1
                
                    #if the number of loops is equal to or greater than the number passed in as an argument with args.number break out of the loop
                    if count >= args.number:
                       break
                   
            #For Movies Only      
            elif (args.allshows == False) and args.allmovies == True:
                movie = get_random_movies(all_Shows_or_Movies_Library_Selection, n=1)

                print('\n\n-----------------------------------')
                print('[RANDOMIZED MOVIES]')
                print(f'Username: {userName}\n')
                print(f'Library Selection: {randomSelectedLibrary}\n')
                print(f'\nMovie Name: \"{movie}\"')
                print(f'\nExcluded Library Sections: {selectionsToExclude_List}')
                print('-----------------------------------\n\n')

                if count == 0:
                    try:
                        #If a playlist with the same name already exist, delete it
                        if plex.playlist(title=args.name):
                            print(f'The playlist "{args.name}" already exist.')
                            print(f'deleting playlist "{args.name}" ...')
                            plex.playlist(title=args.name).delete()

                    except NotFound as e: 
                        logger.debug(f"Playlist {args.name} does not exist to delete.")

                    print(f'\nCreating Playlist ... \n')
                    
                    #Create Playlist 
                    createdPlaylist = Playlist.create(server=plex, title=args.name, items=movie, section=None, smart=False, limit=None, libtype=None, sort=None, filters=None, m3ufilepath=None)
                   
                    print(f'\nCreated Playlist: {args.name}')
                    print(f'\nAdded to Playlist [{args.name}]: {createdPlaylist.items()}\n')
                    
                    #if the number of loops is equal to or greater than the number passed in as an argument with args.number break out of the loop
                    if count >= args.number:
                       break
                       
                    else:
                        count += 1
                
                else:
                    print(f'\nAdding to Playlist ...\n')
                    
                    #Add to Playlist
                    createdPlaylist.addItems(items=movie)

                    print(f'\nAdded to Playlist [{args.name}]: {createdPlaylist.items()}\n')

                    #if the number of loops is equal to or greater than the number passed in as an argument with args.number break out of the loop
                    if count >= args.number:
                       break
                    
                    else:
                        count += 1
                
                #if the number of loops is equal to or greater than the number passed in as an argument with args.number break out of the loop
                if count >= args.number:
                   break

        else:
            print(f'\nERROR - The library \"{randomSelectedLibrary}\" does not exist.\n')
            break


def create_playlist(plex, account):
    #Group All Shows in different Library Sections together (does not include exclluded)
    #Group All Movies in different Library Sections together  (does not include exclluded)

    #If the user passed something into the argument selectlibrary to select their desired libraries
    if(args.select_library != None):
        librarySelection_List = (args.select_library).split(comma)

    #The name of the library sections type IE (MovieSection, ShowSection, MusicSection, PhotoSection) its used to query the type of data too grab from the plex API
    getMovieSection = 'MovieSection'
    getShowSection = 'ShowSection'

    count = 0
    
    getAllSections = plex.library.sections()
    #for the section in allSections (converted to String):
    allSections_String = str(getAllSections)
    allShowSections_String = str()
    allMovieSections_String = str()
    
    #Split all Plex Sections and make it into a list
    allSections_List = allSections_String.split(comma)

    #Obtain All Library Selections (and format it to only have the names of the libraries as they appear in Plex)
    plex_all_library_sections = get_isolate_and_format_plex_element(getAllSections)

    #The Library Sections Minus the excluded Sections
    plex_all_library_sections_minus_exluded = get_isolate_and_format_plex_element(getAllSections)
    
    #use to query and find show sections from the for command if statement
    getShowSectionSearcher = '<' + getShowSection + colon
    getMovieSectionSearcher = '<' + getMovieSection + colon
    
    #Used to determine if a comma should be placed between the string concatination
    countShows = 0
    countMovies = 0
    for section in allSections_List: 
        if getShowSectionSearcher in section:
            if countShows == 0:
                allShowSections_String = allShowSections_String + section
            else:
                allShowSections_String = allShowSections_String + comma + section
            
            countShows += 1
        elif getMovieSectionSearcher in section:
            if countMovies == 0:
                allMovieSections_String = allMovieSections_String + section
            else:
                allMovieSections_String = allMovieSections_String + comma + section
                
            countMovies += 1
        else:
            logger.debug(f'NOT result of section = {section}\n')
    
    #Grab All possible show sections (unfiltered) and set it to a list
    allShowSectionsFull_List = allShowSections_String.split(comma)
    #Grab the List of all possible show sections(unfiltered) and return only the name portion of the Section
    allShowSectionsFull_List = get_isolate_and_format_plex_element(allShowSectionsFull_List)
    
    #Grab All possible Movie (includes videos) sections (unfiltered) and set it to a list
    allMovieSectionsFull_List = allMovieSections_String.split(comma)
    #Grab the List of all possible Movie (includes videos) sections(unfiltered) and return only the name portion of the Section
    allMovieSectionsFull_List = get_isolate_and_format_plex_element(allMovieSectionsFull_List)
    
    #Holds the Formatted Array for both All Movies and Shows only 
    allSections_Formatted_List = list()
    movieSections_Formatted_List = list()
    tvShowsSections_formatted_List = list()
    
    #Assign Argument Data to variables
    selectionsToExclude_List = args.exclude_library.split(comma)
    print(f'selectionsToExclude_List = {selectionsToExclude_List}')
    
    #Used to build a list of everything that was excluded by using the --selectedlibrary. Anything not selected will be added to this exclusion list.
    selectionsToExcludeBasedOnWhatUserSelected_List = list()

    #Formatted to only contain the Names of the library sections
    tvShowsSections_formatted_List = tv_shows_and_Movies_section_formatter(plex)
    movieSections_Formatted_List = tv_shows_and_Movies_section_formatter(plex)

    
    getAllShows = args.allshows
    getAllMovies = args.allmovies
    
    loopCount=0
    for loopCount in range(len(plex_all_library_sections)):

        library = plex_all_library_sections[loopCount]
        
        if len(plex_all_library_sections_minus_exluded) == 0:
            print(f'All Libraries were selected to be excluded.')
            exit(1)

        #If the user is selecting there libraries manually then remove anything not in the selection    
        if (args.select_library != None):

            #if library is not one of the selected sections requested by the user, remove it.
            if not library in librarySelection_List:
                #Add the library to the Full list of what was excluded library sections for everything that is not in --selectlibrary argument passed in by the user
                selectionsToExcludeBasedOnWhatUserSelected_List.append(library)
                
                logger.debug(f'Removing library \"{library}\" from plex_all_library_sections_minus_exluded List')
                
                #Remove the library section from the list of sections that will be used for forming the plex library sections to query for media
                removedLibrarySection = plex_all_library_sections_minus_exluded.remove(library)

                #Reduce the loopCount by one since we just removed an entry from the list we need to move the counter back by one to check he value that was moved into the current loop number
                loopCount -= 1

        else:
            if library in selectionsToExclude_List:
                logger.debug(f'Removing library \"{library}\" from plex_all_library_sections_minus_exluded List')
                
                removedLibrarySection = plex_all_library_sections_minus_exluded.remove(library)

                #Reduce the loopCount by one since we just removed an entry from the list we need to move the counter back by one to check he value that was moved into the current loop number
                loopCount -= 1
                
            elif (args.allshows == True) and (args.allmovies == False) and (args.select_library == None):    
                if (library in allMovieSectionsFull_List) and (library in plex_all_library_sections_minus_exluded):
                    removedLibrarySection = plex_all_library_sections_minus_exluded.remove(library)
                    
                    logger.debug(f'Removing library \"{library}\" from plex_all_library_sections_minus_exluded List')
                    
                    #Reduce the loopCount by one since we just removed an entry from the list we need to move the counter back by one to check he value that was moved into the current loop number
                    loopCount -= 1
                    
            elif (args.allshows == False) and (args.allmovies == True) and (args.select_library == None):
                if (library in allShowSectionsFull_List) and (library in plex_all_library_sections_minus_exluded):
                    logger.debug(f'Removing library \"{library}\" from plex_all_library_sections_minus_exluded List')
                    
                    removedLibrarySection = plex_all_library_sections_minus_exluded.remove(library)

                    #Reduce the loopCount by one since we just removed an entry from the list we need to move the counter back by one to check he value that was moved into the current loop number
                    loopCount -= 1
            
            
    logger.debug(f'\n\nplex_all_library_sections_minus_exluded = {plex_all_library_sections_minus_exluded}\n')    
    
    
    #If user did not choose to group together all Shows or Movies
    #if getAllShows == False and getAllMovies == False:
    #If only TV Shows were selected (Chosen by user)
    if args.select_library != None:
        tvShowsSections_formatted_List = tv_shows_and_Movies_section_formatter(plex)

        #Build the playlist, first generates a playlist, then fills it.
        build_playlist(plex, account, plex_all_library_sections_minus_exluded, selectionsToExcludeBasedOnWhatUserSelected_List)
    
    #If only TV Shows were selected
    elif args.allshows == True and args.allmovies == False:
        tvShowsSections_formatted_List = tv_shows_and_Movies_section_formatter(plex)
        
        #Build the playlist, first generates a playlist, then fills it.
        build_playlist(plex, account, tvShowsSections_formatted_List, selectionsToExclude_List)
    
    #If only Movies were selected
    elif args.allshows == False and args.allmovies == True:
        movieSections_Formatted_List = tv_shows_and_Movies_section_formatter(plex)
        
        #Build the playlist, first generates a playlist, then fills it.
        build_playlist(plex, account, movieSections_Formatted_List, selectionsToExclude_List)
     
    #-----Else if both TV Shows and Movies were selected-----
    else: 
        #Build the playlist, first generates a playlist, then fills it.
        build_playlist(plex, account, plex_all_library_sections, selectionsToExclude_List)

    return plex


#Take the imported data from a plex object and reformat it to only have data after the the last colon of each element, and also any carrot symbols.
#This also converts any hyphens to a space since Plex saves spaces as Hyphens for plex objects
# I.E [<MyPlexUser:123456789:Plex-User>] would become ['Plex User']
def get_isolate_and_format_plex_element(plexElements):

    try:
        plexElementFormatted = list()
                
        if(type(plexElements) == str):
            plexElements = str(plexElements).replace('-', ' ')

            #split the data by colons and keep the last splits data
            plexElements = plexElements.split(colon)[-1]

            #remove the last character from the data because after using the split command above, the last character will be a '>' character
            plexElements = plexElements[:-1]

            #If the First character is a less than carrot, remove it
            if plexElements[1:] == '<':
                plexElements = plexElements.replace('<', '', 1)

            #If the Last character is a greater than carrot, remove it
            if plexElements[-1:] == '>':
                plexElements = plexElements.replace('>', '', 1)

            plexElementFormatted = plexElements
            
        else:
            for plexElement in plexElements:

                plexElement = str(plexElement).replace('-', ' ')

                #split the data by colons and keep the last splits data
                plexElement = plexElement.split(colon)[-1]

                #remove the last character from the data because after using the split command above, the last character will be a '>' character
                plexElement = plexElement[:-1]
                
                #If the First character is a less than carrot, remove it
                if plexElement[1:] == '<':
                    plexElement = plexElement.replace('<', '', 1)

                #If the Last character is a greater than carrot, remove it
                if plexElement[-1:] == '>':
                    plexElement = plexElement.replace('>', '', 1)
                    
                plexElementFormatted.append(plexElement)
        
    except:
        print(f'Unable to format the Element \"{plexElements}\"')

    return plexElementFormatted


def tv_shows_and_Movies_section_formatter(plex):

    getAllSections = plex.library.sections()
    
    #The name of the library sections type IE (MovieSection, ShowSection, MusicSection, PhotoSection) its used to query the type of data too grab from the plex API
    getMovieSection = 'MovieSection'
    getShowSection = 'ShowSection'
    
    #allMediaTypes = [getMovieSection, getShowSection, getMusicSection, getPhotoSection]
    allVideoMediaTypes = [getMovieSection, getShowSection]
    selectedMediaTypes = list()
    
    logger.debug(f'\nallVideoMediaTypes = {allVideoMediaTypes}\n')
    
    if(args.select_library != None) or (args.allshows == True):
        selectedMediaTypes = [getShowSection]
        #If both TV Shows and movies were selected
        if(args.allmovies == True):
            selectedMediaTypes = [getShowSection, getMovieSection]
            
        logger.debug(f'\nselectedMediaTypes = {selectedMediaTypes}\n')
        
    elif(args.allmovies == True):
        selectedMediaTypes = [getMovieSection]
        #If both TV Shows and movies were selected
        if(args.select_library != None) or (args.allshows == True):
            selectedMediaTypes = [getShowSection, getMovieSection]
            
        logger.debug(f'\nselectedMediaTypes = {selectedMediaTypes}\n')

    else:
        print(f'\nError - Unkown library selection type.\n')
        exit(1)
        
    
    #Return the full list of possible library section types and library names IE ([<ShowSection:1:TV-Shows>, <MusicSection:2:Anime-Music>, <MovieSection:3:Movies>])
    getAllSections = plex.library.sections()
    
    allSections_String = str(getAllSections)
    allShowSections_String = str()
    allMovieSections_String = str()
    
    #Holds the Formatted Array for both All Movies and Shows only 
    allSections_Formatted_List = list()
    movieSections_Formatted_List = list()
    tvShowsSections_formatted_List = list()
    
    #Assign Argument Data to variables
    selectionsToExclude_List = args.exclude_library.split(comma)
    getAllShows = args.allshows
    getAllMovies = args.allmovies
 
    #This will have the total list from movie's section and tv shows sections (except the exluded data from 'selectionsToExclude')
    fullSectionCounter = 0
    movieSectionCounter = 0
    tvShowSectionCounter = 0

    if(args.select_library != None):
        #Split the args.select_library (--selectlibrary) argument and make it into a list
        selectedLibrary_List = args.select_library.split(comma)
        logger.debug(f'selectedLibrary_List = {selectedLibrary_List}')
        
    #Split all Plex Sections and make it into a list
    allSections_List = allSections_String.split(comma)

    #use to query and find show sections from the for command if statement
    getShowSectionSearcher = '<' + getShowSection + colon
    getMovieSectionSearcher = '<' + getMovieSection + colon
    
    #Used to determine if a comma should be placed between the string concatination (add comma after 1st entry is added)
    countShows = 0
    countMovies = 0
    for section in allSections_List: 
        if getShowSectionSearcher in section:
            if countShows == 0:
                allShowSections_String = allShowSections_String + section
            else:
                allShowSections_String = allShowSections_String + comma + section
            
            countShows += 1
        elif getMovieSectionSearcher in section:
            if countMovies == 0:
                allMovieSections_String = allMovieSections_String + section
            else:
                allMovieSections_String = allMovieSections_String + comma + section
            countMovies += 1
        else:
            print (f'NOT result of section = {section}\n')
    
    
    
    allShowSections_List = allShowSections_String.split(comma)
    allMovieSections_List = allMovieSections_String.split(comma)

    if ((args.allshows == True) or (args.select_library != None)) and (args.allmovies == True):
        #Format All Show Sections properly and make it iterable. Then Assign it to allSections_Formatted_List in order to uuse it in the below for loop
        allSections_Formatted_List = get_isolate_and_format_plex_element(allSections_List)
        
        for section in allSections_Formatted_List:
            if section in selectionsToExclude_List:
                allSections_Formatted_List.remove(section)
            elif (args.select_library != None) and (section not in selectedLibrary_List):
                allSections_Formatted_List.remove(section)
        
        print(f'\n[Using All Shows, and Using All Movies]')
        logger.debug(f'allSections_Formatted_List: {allSections_Formatted_List}\n')
        
        return allSections_Formatted_List
        
    elif (args.allshows == True) and (args.allmovies == False):
        #Format All Show Sections properly and make it iterable. Then Assign it to allSections_Formatted_List in order to uuse it in the below for loop
        tvShowsSections_formatted_List = get_isolate_and_format_plex_element(allShowSections_List)
        
        for section in tvShowsSections_formatted_List:
            if section in selectionsToExclude_List:
                tvShowsSections_formatted_List.remove(section)
            elif (args.select_library != None) and (section not in selectedLibrary_List):
                tvShowsSections_formatted_List.remove(section)
        
        print(f'\n[Using All Shows]')
        logger.debug(f'tvShowsSections_formatted_List: {tvShowsSections_formatted_List}\n')
        
        return tvShowsSections_formatted_List
    elif (args.allshows == False) and (args.allmovies == True):
        #Format All Movies Sections properly and make it iterable. Then Assign it to allSections_Formatted_List in order to uuse it in the below for loop
        movieSections_Formatted_List = get_isolate_and_format_plex_element(allMovieSections_List)
        
        for section in movieSections_Formatted_List:
            if section in selectionsToExclude_List:
                movieSections_Formatted_List.remove(section)
            elif (args.select_library != None) and (section not in selectedLibrary_List):
                movieSections_Formatted_List.remove(section)
        
        
        print(f'\n[Using All Movies]')
        logger.debug(f'movieSections_Formatted_List: {movieSections_Formatted_List}\n')
        
        return movieSections_Formatted_List
    
    
    elif(args.select_library != None):
        
        allSections_Formatted_List = get_isolate_and_format_plex_element(allSections_List)
        
        for section in allSections_Formatted_List:
            if section not in selectionsToExclude_List:
                allSections_Formatted_List.remove(section)

        
        print(f'\n[Using All Shows, and Using All Movies]\n')
        logger.debug(f'allSections_Formatted_List: {allSections_Formatted_List}\n')
        
        return allSections_Formatted_List
    
    else:
        print(f'ERROR - Unable to generate formatted Library Sections.')
        exit(1)
    

def fetch_plex_api(path='', method='GET', plextv=False, **kwargs):
    """Fetches data from the Plex API"""

    url = 'https://plex.tv' if plextv else PLEX_URL.rstrip('/')


    headers = {'X-Plex-Token': args.token,
               'Accept': 'application/json'}

    params = {}
    if kwargs:
        params.update(kwargs)

    try:
        if method.upper() == 'GET':
            r = requests.get(url + path,
                             headers=headers, params=params, verify=False)
        elif method.upper() == 'POST':
            r = requests.post(url + path,
                              headers=headers, params=params, verify=False)
        elif method.upper() == 'PUT':
            r = requests.put(url + path,
                             headers=headers, params=params, verify=False)
        elif method.upper() == 'DELETE':
            r = requests.delete(url + path,
                                headers=headers, params=params, verify=False)
        else:
            print("Invalid request method provided: {method}".format(method=method))
            return

        if r and len(r.content):
            if 'application/json' in r.headers['Content-Type']:
                return r.json()
            elif 'application/xml' in r.headers['Content-Type']:
                return xmltodict.parse(r.content)
            else:
                return r.content
        else:
            return r.content

    except Exception as e:
        print("Error fetching from Plex API: {err}".format(err=e))


def get_user_tokens(server_id):
    api_users = fetch_plex_api('/api/users', plextv=True)

    api_shared_servers = fetch_plex_api('/api/servers/{server_id}/shared_servers'.format(server_id=server_id), plextv=True)
    user_ids = {user['@id']: user.get('@username', user.get('@title')) for user in api_users['MediaContainer']['User']}
    users = {user_ids[user['@userID']]: user['@accessToken'] for user in api_shared_servers['MediaContainer']['SharedServer']}
 
    #Return the Profile Name
    return users
    
def get_user_id(server_id):
    api_users = fetch_plex_api('/api/users', plextv=True)

    api_shared_servers = fetch_plex_api('/api/servers/{server_id}/shared_servers'.format(server_id=server_id), plextv=True)
    user_ids = {user['@id']: user.get('@username', user.get('@title')) for user in api_users['MediaContainer']['User']}
    users = {user_ids[user['@userID']]: user['@accessToken'] for user in api_shared_servers['MediaContainer']['SharedServer']}
 
    #Return the ids
    return user_ids


#Generate the users playlist for Server Method
#def generate_all_users_playlist_via_server_method(base_url, authToken, homeUsers):
def generate_all_users_playlist_via_server_method(base_url, authToken, homeUsers=None):

    getAllUsers = 'all'

    plex_server = PlexServer(baseurl=base_url, token=authToken, session=None)
    logger.debug('\nGetting Library Sections...\n')
    
    plex_library_sections = plex_server.library.sections()
    logger.debug(f'Plex Sections: {plex_library_sections}\n')

    #If Home Users was selected check to see if it contains 'all'
    if(args.homeusers != None):
        #If the User passed in the string 'all' (case incensitive) into the argument --homeusers.
        #Regardless of if it is the only entry or within the list, then set the variable setAllHomeUsers to true.
        if getAllUsers.lower() in (homeUser.lower() for homeUser in homeUsers):
            print(f'\nFull List of Home Users Requested. \n')

            print('Retrieving All Home Users ...\n')
            
            setAllHomeUsers = True
            allHomeUsers = get_isolate_and_format_plex_element(plex_server.myPlexAccount().users())

            logger.debug(f'\nAll Home Users: {allHomeUsers}\n')

        else:
            setAllHomeUsers = False
            
    else:
        setAllHomeUsers = False

    #Get A list of all Home Users
    plex_users = get_user_tokens(plex_server.machineIdentifier)

    #If the user selected the --adminuser argument the script will also add the library to the admin account
    if(args.adminuser == True):
        try:
        #if plex_user in homeUsers: 
            print('\nChecking if the user is the Plex Home Admin...')
            
            #If the account is the Plex Home admin (True if it is, false if not).
            isHomeAdmin = plex_server.myPlexAccount().homeAdmin
            
            if (isHomeAdmin == True):
                print('\nThis is indeed the Home Admin\n')
            else:
                print('\nThis is NOT the Home Admin!\nExiting...\n')
                exit(1)

            adminUser = plex_server.myPlexAccount()
            #Get the Admin User Account Name
            adminUser = get_isolate_and_format_plex_element(str(adminUser))

            print(f'\n-----------[BEGIN]-------------- {adminUser} -------------[BEGIN]--------------')
            
            print(f'Current User [Admin]: {adminUser}\n')

            #If the --purge argument was passed in then delete the playlist if it exist
            if(args.purge == True):
                delete_playlist(plex_server, adminUser, args.name)
            else:
                create_playlist(plex_server, adminUser) 
            print(f'------------[END]------------- {adminUser} --------------[END]-------------\n')  

        except Unauthorized:
            print(f'User \"{adminUser}\" is Unauthorized to access the Plex Home \"{args.resource}\"')

        except NotFound:
            print(f'User \"{adminUser}\" is not in the Plex Home \"{args.resource}\"')
    
    if setAllHomeUsers == True:
        print('\n###Obtaining Home Users [ALL USERS]###\n\n')
        for plex_user in allHomeUsers:
            try:
                logger.debug('\nChecking if the current user is a Plex Home guest...\n')
                logger.debug(f'Switching to user: [{plex_user}] ...\n')
                
                print(f'\n-----------[BEGIN]-------------- {plex_user} -------------[BEGIN]--------------')         
                
                runningAsUser = plex_server.myPlexAccount().switchHomeUser(user=plex_user, pin=None).resource(args.resource).connect()
                
                print(f'\nCurrent User [Home User]: {plex_user}\n\n')

                #If the --purge argument was passed in then delete the playlist if it exist
                if(args.purge == True):
                    delete_playlist(runningAsUser, plex_user, args.name)
                else:    
                    create_playlist(runningAsUser, plex_user) 
                    print(f'\nPlaylist Creation for user [{plex_user}] - COMPLETED\n')
                print(f'------------[END]------------- {plex_user} --------------[END]-------------')
                    
            except Unauthorized:
                print(f'User \"{plex_user}\" is Unauthorized to access the Plex Home \"{args.resource}\"')

            except NotFound:
                print(f'User \"{plex_user}\" is not in the Plex Home \"{args.resource}\"')
                
    else:                
        for homeUser in homeUsers:        
            if homeUser in plex_users:
                try:
                    #if plex_user in homeUsers: 
                    logger.debug('\nChecking if the user is a Plex Home guest...\n')
                    logger.debug(f'\nHome User [matched]: {str(homeUser)}\n')    
                    logger.debug(f'Switching to user: [{homeUser}] ...\n')
                    
                    print(f'-----------[BEGIN]-------------- {homeUser} -------------[BEGIN]--------------')
                                   
                    runningAsUser = plex_server.myPlexAccount().switchHomeUser(user=homeUser, pin=None).resource(args.resource).connect()
                    
                    print(f'Current User: {str(runningAsUser)}\n\n')

                    #If the --purge argument was passed in then delete the playlist if it exist
                    if(args.purge == True):
                        delete_playlist(runningAsUser, homeUser, args.name) 
                    else: 
                        create_playlist(runningAsUser, homeUser)
                        print(f'\nPlaylist Creation for user [{homeUser}] - COMPLETED\n')                        
                    print(f'------------[END]------------- {homeUser} --------------[END]-------------')  

                except Unauthorized:
                    print(f'User \"{homeUser}\" is Unauthorized to access the Plex Home \"{args.resource}\"')

                except NotFound:
                    print(f'User \"{homeUser}\" is not in the Plex Home \"{args.resource}\"')
            else:
                continue


def generate_all_users_playlist_via_account_method(plexConnection, accountInfo, homeUsers):

    getAllUsers = 'all'
    
    #list of All plex users
    allHomeUsers = get_isolate_and_format_plex_element(plexConnection.myPlexAccount().users())
    
    print(f'list home users: {homeUsers}')

    print(f'\nplex_account = {accountInfo}\n')
    plex_library_sections = plexConnection.library.sections()
    print(f'\nplex_library_sections = {plex_library_sections}\n')

    #If Home Users was selected, check to see if it contains 'all'
    if(args.homeusers != None):
        #If the User passed in the string 'all' (case incensitive) into the argument --homeusers.
        #Regardless of if it is the only entry or within the list, then set the variable setAllHomeUsers to true.
        if getAllUsers.lower() in (homeUser.lower() for homeUser in homeUsers):
            print(f'\nFull List of Home Users Requested. {homeUsers}\n')
            print('Retrieving All Home Users ...\n')
            
            setAllHomeUsers = True

            logger.debug(f'\nAll Home Users: {allHomeUsers}\n')
        else:
            setAllHomeUsers = False
    else:
        setAllHomeUsers = False
    
    #If the user selected the --adminuser argument the script will also add the library to the admin account
    if(args.adminuser == True):
        try:
        #if plex_user in homeUsers: 
            print('\nChecking if the user is the Plex Home Admin...')
            
            #If the account is the Plex Home admin (True if it is, false if not).
            isHomeAdmin = plexConnection.myPlexAccount().homeAdmin
            
            if (isHomeAdmin == True):
                print('\nThis is indeed the Home Admin\n')
            else:
                print('\nThis is NOT the Home Admin!\nExiting...\n')
                exit(1)

            adminUser = plexConnection.myPlexAccount()
            #Get the Admin User Account Name
            adminUser = get_isolate_and_format_plex_element(str(adminUser))

            print(f'\n-----------[BEGIN]-------------- {adminUser} -------------[BEGIN]--------------')
            
            print(f'Current User [Admin]: {adminUser}\n')

            #If the --purge argument was passed in then delete the playlist if it exist
            if(args.purge == True):
                delete_playlist(plexConnection, adminUser, args.name)
            else:
                create_playlist(plexConnection, adminUser) 
            print(f'------------[END]------------- {adminUser} --------------[END]-------------\n')  

        except Unauthorized:
            print(f'User \"{adminUser}\" is Unauthorized to access the Plex Home \"{args.resource}\"')

        except NotFound:
            print(f'User \"{adminUser}\" is not in the Plex Home \"{args.resource}\"')
    
    #If the user passed in the word "all" as a home user the script will run for every home user profile
    if setAllHomeUsers == True:
        print('\n###Obtaining Home Users [ALL USERS]###\n\n')
        for plex_user in allHomeUsers:
            try:
                logger.debug('\nChecking if the current user is a Plex Home guest...\n')
                logger.debug(f'Switching to user: [{plex_user}] ...\n')
                
                print(f'\n-----------[BEGIN]-------------- {plex_user} -------------[BEGIN]--------------')         
                
                runningAsUser = plexConnection.myPlexAccount().switchHomeUser(user=plex_user, pin=None).resource(args.resource).connect()
                
                print(f'\nCurrent User [Home User]: {plex_user}\n\n')

                #If the --purge argument was passed in then delete the playlist if it exist
                if(args.purge == True):
                    delete_playlist(runningAsUser, plex_user, args.name)
                else:    
                    create_playlist(runningAsUser, plex_user) 
                    print(f'\nPlaylist Creation for user [{plex_user}] - COMPLETED\n')
                print(f'------------[END]------------- {plex_user} --------------[END]-------------')
                    
            except Unauthorized:
                print(f'User \"{plex_user}\" is Unauthorized to access the Plex Home \"{args.resource}\"')

            except NotFound:
                print(f'User \"{plex_user}\" is not in the Plex Home \"{args.resource}\"')
                
    else:                
        for homeUser in homeUsers:        
            if homeUser in allHomeUsers:
                try:
                    #if plex_user in homeUsers: 
                    logger.debug('\nChecking if the user is a Plex Home guest...\n')
                    logger.debug(f'\nHome User [matched]: {str(homeUser)}\n')    
                    logger.debug(f'Switching to user: [{homeUser}] ...\n')
                    
                    print(f'-----------[BEGIN]-------------- {homeUser} -------------[BEGIN]--------------')
                                   
                    runningAsUser = plexConnection.myPlexAccount().switchHomeUser(user=homeUser, pin=None).resource(args.resource).connect()
                    
                    print(f'Current User: {str(runningAsUser)}\n\n')

                    #If the --purge argument was passed in then delete the playlist if it exist
                    if(args.purge == True):
                        delete_playlist(runningAsUser, homeUser, args.name) 
                    else: 
                        create_playlist(runningAsUser, homeUser)
                        print(f'\nPlaylist Creation for user [{homeUser}] - COMPLETED\n')                        
                    print(f'------------[END]------------- {homeUser} --------------[END]-------------')  

                except Unauthorized:
                    print(f'User \"{homeUser}\" is Unauthorized to access the Plex Home \"{args.resource}\"')

                except NotFound:
                    print(f'User \"{homeUser}\" is not in the Plex Home \"{args.resource}\"')
            else:
                continue


def main():
    global args
    args = get_args()
    plex = None

    #If the user enters the selectLibrary argument
    if(args.select_library != None) and (args.allshows == True):
        print(f'\nERROR - The \"selectLibrary\" argument cannot be used in conjunction with the \"allShows\" argument.\n')
        exit(1)
    elif(args.select_library != None) and (args.allmovies == True):
        print(f'\nERROR - The \"selectLibrary\" argument cannot be used in conjunction with the \"allmovies\" argument.\n')
        exit(1)

    #If the user does not pass in either of the following arguments: --selectlibrary, --allshows, or --allmovies
    if(args.select_library == None) and (args.allshows == False) and (args.allmovies == False):
        print('\nERROR - One of the required arguments must be selected.')
        print(f'        Rerun your command with one of the following required Arguments:')
        print(f'        --selectlibrary\n        --allshows\n        --allmovies\n')
        time.sleep(3)
        exit(1)

    #If the Playlist Name is empty
    if(args.name == None) or (args.name == ""):
        print(f'\nThe argument \"--name\" cannot be empty.\nPlease provide the name argument and try again.\n')
        exit(1)
    elif(args.name == False):
        print(f'The argument \"--name\" is required and cannot be ommitted.\nPlease provide the name argument and try again.\n')
        exit(1)
       
    if(args.number > 0):
        #Select home Users
        if(args.homeusers):
            homeUsers = args.homeusers.split(comma)
        else:
            homeUsers = list()
        
        #Split each Library selection and each excluded library to build a list
        if (args.select_library != None):
            selectedLibrariesList = (args.select_library).split(comma)
            
        if (args.exclude_library != None):
            excludedLibrariesList = (args.exclude_library).split(comma)
        
        if (args.select_library != None) and (args.exclude_library != None):
            #Verify that the selected Library is not in the excluded libraries list
            for selectedLibrary in selectedLibrariesList:
                if selectedLibrary in excludedLibrariesList:
                    print(f'\nThe selected Library {selectedLibrary} cannot be included in the \"excludedlibrary\" argument.\n')
                    exit(1)
        
        #print the excluded library generated by --exclude-library argument to the user in case they used the default value and did know that libraries are being excluded without passing it in as an argument manually.
        if(args.exclude_library != None):
            print(f'\nLibrary Sections to exclude [--exclude-library]: {excludedLibrariesList}\n')
            
        
        if args.debug:
            logger.setLevel(logging.DEBUG)
            
        #If the authorization method is Server
        if (args.account == True) and (args.server == False):
        
            #If the username argument is empty or missing
            if(args.username == None) or (args.username == ""):
                print(f'\nThe argument \"--username\" is required and cannot be empty.\n')
                exit(1)
                
            #If the password argument is empty or missing
            elif(args.password == None) or (args.password == ""):
                print(f'\nThe argument \"--password\" is required and cannot be empty.\n')
                exit(1)
            
            #If the resource argument is empty or missing
            elif(args.resource == None) or (args.resource == ""):
                print(f'\nThe argument \"--resource\" is required for the account connection method, and cannot be empty.\n')
                exit(1)
            
            # ## Connect via Account
            account = MyPlexAccount(args.username, args.password)
            plex = account.resource(args.resource).connect()
            
            #Generate Playlist for the requested Account (Method) Users
            if (args.homeusers != False):
                generate_all_users_playlist_via_account_method(plex, account, homeUsers)
            else:
                generate_all_users_playlist_via_account_method(plex, account)
        
        #If the authorization method is Server
        elif (args.server == True) and (args.account == False):
            #If the baseurl argument is empty or missing
            if(args.baseurl == None) or (args.baseurl == ""):
                print(f'\nThe Base URL is required and cannot be empty.\n')
                exit(1)
                
            #If the auth token argument is empty or missing
            elif(args.token == None) or (args.token == ""):
                print(f'\nThe Auth Token is required and cannot be empty.\n')
                exit(1)

            #Connect via Direct URL
            #Generate Playlist for the requested Server (Method) Users
            if (args.homeusers != False):
                generate_all_users_playlist_via_server_method(args.baseurl, args.token, homeUsers)
            else:
                generate_all_users_playlist_via_server_method(args.baseurl, args.token)
            
        else:
            #print That the connection method is required to proceed.
            print(f'\nERROR - The script requires the use of ONE connection method to proceed.\n\nAvailable options:\n [1] - account (--account) \n [2] - server (--server)\n')
            exit(1)
            
    else:
        print(f'\nError - \"args.number\" must be greater than 0.\n')
        exit(1)
        


if __name__ == '__main__':
    main()
